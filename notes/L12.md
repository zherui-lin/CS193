# Lecture 12

## Ajax (formly Asynchronous JavaScript and XML)
- One of the most important tools for the client side
- Ajax makes requests to the server, and the server can respond with some data instead of a new HTML file that can help modify the current client side
- Ajax is important for single page applications (SPAs), which will replace the contents of the current page and the website only need one single page
- In the past the data responded from the server is in the format of XML, but recently JSON is more common, and thus 'AJAX' will not be an acronym any more
- Data transferred can be commonly XML or JSON, XML is codes similar to HTML, while JSON is representations of an object or an array of objects
    - JSONs can be converted to JS objects by `JSON.parse()`, in the past it is processed simply by `eval()`
    - JS objects can be stringified to JSONs by `JSON.stringify()`, but remember that an object which refers to itself (with circular reference) cannot be stringified to JSON
- Instead of using `try ... catch`, errors can be handled in other ways
    - errors can be handled by adding event handler to `"error"` events on elems, when the document object model has a problem, it causes a error event
        ```js
        var gatesImg = document.getElementById("Gates");
        var greenImg = document.getElementById("Green");
        gatesImg.addEventListener("load",
                    () => console.log("Gates Building Loaded"));
        gatesImg.addEventListener("error",
                    () => console.log("Gates Building  Not Loaded"));            
        greenImg.addEventListener("load",
                    () => console.log("Green Library Loaded"));
        greenImg.addEventListener("error",
                    () => console.log("Green Library Not Loaded"));
        ```
    - errors in responses from servers should also be handled in another similar way

## Promises
- Promise is a general mechanism combining event handling and error handling
- Promise is a replacement for callbacks, and it can also handle errors
- When using promises in this case, we are considered as clients to promises, we only specify what to do with the successful result from the server and how to handle errors if requests fail
- Promise objects can be processed after the task finishes by `.then()`, which will take a function as parameter specifying how to deal with the result
    ```js
    function randomLuck() {
        return new Promise((resolve, reject) => {
            setTimeout(()=> {
                var random = Math.random();
                if (random < 0.5) {
                    resolve("won");
                } else {
                    reject("lost");
                }
            }, 1000);
        })
    }
    var thePromise = randomLuck();
    thePromise.then(() => console.log("We won!"));
    ```
- `.then()` can take another function as parameter specifying how to handle errors
    ```js
    var thePromise = randomLuck();
    thePromise.then(() => console.log("We won!"),
                    () => console.log("We lost :-("));
    ```
- `.catch()` takes only one function as parameter handling errors
    ```js
    var thePromise = randomLuck();
    thePromise.catch(() => console.log("We lost :-("));
    ```
- `.finally()` takes one function as parameter that will always be called
    ```js
    var thePromise = randomLuck();
    thePromise.finally(() => console.log("It was resolved"));
    ```
- status of a promise can be pending and settled (including fullfilled and rejected), function taken by `.finally()` will be called once the status is settled
- `.then()` can be called multiple times on a single promise, and if the promise was already settled, the function will still run
- functions passed in can also take parameters, encapsulated promises will decide what arguments will be passed in when the functions get called, which will generally be results from promised process or errors caused
    ```js
    var thePromise = randomValue();
    thePromise.then((result) => console.log("We won with " + result));
    ```
- `.then()` can be called multiple times seperately, with different functions passed in
    ```js
    var thePromise = randomLuck();
    thePromise.then(() => console.log("We won!"));
    thePromise.then(() => console.log("This is great!"));
    thePromise.then(() => console.log("I'm so happy"));
    ```
- `.then()` can also be chained, in which case the function we passed in should also return a promise, only when the returned promise responds successfully, the function passed in following `.then()` as the first parameter will get called
    ```js
    var thePromise = randomLuck();
    thePromise.then(() => {
                console.log("We won once!");
                return randomLuck();
            })
        .then(() => {
                console.log("We won again!");
                return randomLuck();
            })
        .then(() => {
                console.log("We won three times!");
            });
    ```
- Errors in a `.then()` chain can be simply handled by a single `.catch()` at the end of the chain, we will automatically jump to last catch from anywhere in the chain, but this feature is a little bit logically weird
    ```js
    var thePromise = randomLuck();
    thePromise.then(() => {
                console.log("We won once!");
                return randomLuck();
            })
        .then(() => {
                console.log("We won again!");
                return randomLuck();
            })
        .then(() => {
                console.log("We won three times!");
            })
        .catch(() => {
                console.log("We lost");
            });
    ```
- The function passed in at the front part of the chain does not have to return a promise, instead it can return anything and it will be passed to the following function passed in
    ```js
    function randomValue() {
        return new Promise((resolve, reject) => {
            setTimeout(()=> {
                var randomNumber = Math.floor(Math.random() * 10 + 1);
                if (randomNumber > 5) {
                    resolve(randomNumber);
                } else {
                    reject(randomNumber);
                }
            }, 1000);
        })
    }
    var thePromise = randomValue();
    thePromise.then((result) => {
                console.log("We won with " + result);
                return result;
            })
            .then((result) => {
                var newResult = result * 2
                console.log("result now " + newResult);
                return newResult;
            })
            .then((result) => {
                var newResult = result * 2
                console.log("result now " + newResult);
                return newResult;
            })
            .catch(() => {
                console.log("We lost");
            });
    ```

## Fetch
- Fetch is based on promises
- `fetch()` can take a URL as parameter and return a promise where a XML or a JSON extracted from that URL will be included in the response
- `.json()` of the response will be another promise where a JS object parsed from the JSON will be the response
    ```js
    var fetchPromise = fetch('http://web.stanford.edu/~psyoung/cs193c/feed.json');
    fetchPromise.then((response) => {
        // we want to parse the JSON returned, but that
        // is itself a promise
        var jsonPromise = response.json();
        jsonPromise.then((jsonResult) => processNews(jsonResult));
    });
    function processNews(jsonResult) {
        console.log(jsonResult);
        var newHTML = "<ul>";
        for(let item of jsonResult.items) {
            newHTML = newHTML + "<li>" 
                    + item.title
                    + "</li>";        
        }
        newHTML = newHTML + "</ul>";
        document.getElementById("news").innerHTML = newHTML;
    }
    ```
- We can also make a chained promise and add error handling as a more compact format
    ```js
    fetch('http://web.stanford.edu/~psyoung/cs193c/feed.json')
        .then((response) => response.json())
        .then((jsonResult) => processNews(jsonResult))
        .catch(notifyOfError);
    function notifyOfError(err) {
        console.log(err);
        var errMsg = "<p>" + err.msg + "</p>";
        document.getElementById("news").innerHTML = errMsg;
    }
    ```

7-28 1:10:00

