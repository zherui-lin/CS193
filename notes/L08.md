# Lecture 8 JavaScript Object Model
- Destructuring
- JavaScript Objects

## Destructuring
- Destructuring is a technique to retrieve data from a JavaScript object or array and store it in a more convenient or accessible format
- It seems like we are declaring a new object with properties from an existing object, and the property names of the new object can be accessed by the general scope
- Note that we have to use `var` instead of `let`, otherwise the general scope cannot access variables defined in a pair of curly braces (object)
- We can extract certain properties from an object by property names and the ordering does not matter
    ```js
    var ex = {a: 1, b: 2, c: 3, d: 4};
    var {a, d} = ex;
    var {c, b} = ex;
    console.log(a); // 1
    console.log(b); // 2
    console.log(c); // 3
    console.log(d); // 4
    ```
- We can initialize some default values for properties
    ```js
    var {a = 10, d = 20, e = 30} = ex;
    console.log(e); // 30
    ```
- We can also rename the results which will not declare a variable whose name is the property name
    ```js
    var a = 12, b = 15;
    var {a: x, b: y} = ex;
    console.log(x); // 1
    console.log(y); // 2
    console.log(a); // 12
    console.log(b); // 15
    ```
- If the variables are already defined, just using curly braces will be a syntax error since JS will think we are writing a block of code (curly braces have different contexts), we can use parentheses to prevent ambiguity
    ```js
    var a, b;
    {a, b} = ex; // error
    ({a, b} = ex); // valid
    ```
- Destructing also works with arrays, where variables get processed are basically in order
    ```js
    var ex = ["alpha", "bravo", "charlie", "delta"];
    var [a, b] = ex;
    console.log(a); // "alpha"
    console.log(b); // "bravo"
    ```
- We can skip items
    ```js
    var [a, , , d] = ex;
    console.log(a); // "alpha"
    console.log(d); // "delta"
    ```
- We can also wrap remaining items all in one variable
    ```js
    var [a, b, ... rest] = ex;
    console.log(rest); // ["charlie", "delta"]
    ```
- We can also set default values
    ```js
    var [a = "able", b = "baker", c = "charlie", d = "dog", e = "echo"] = ex;
    console.log(a); // "alpha"
    console.log(c); // "charlie"
    console.log(e); // "echo"
    ```
- Destructing is handy for import and output
    - a module can output a bunch of stuffs, but we can only import what we are interested by destructing
        ```js
        function importMathStuff() { 
            return {
                pi: 3.14,
                e: 2.71828,
                power: (base, exp) => {
                    let result = 1;
                    for(let i=0; i<exp; i++) {
                        result *= base;
                    }
                    return result;
                }
            };
        }
        var {pi, power} = importMathStuff(); // not interested in e
        var radius = 1;
        console.log(2 * pi * radius);
        console.log(power(2,10));
        ```
    - also supports return multiple values (in one single object)

## JavaScript Objects
- Objects can be defined as object literal (property-value pairs), properties are strings (or symbols) but not quoted
    ```js
    var example = {
		name: "Molly",
		nickname: "FloPup",
		canine: true,
		age: 8
	};
    ```
- We can access properties of an object by either '.' or square brackets (properties should be quoted, otherwise a variable with the name as the property will be access, and the actually property accessed will be the value of that variable)
    ```js
    example.age = example.age + 1;
    example["age"] = example["age"] + 1;
    var key = "age";
    example[key] = example[key] + 1; // equivalent to above
    ```
- New properties can be added after an object is created by either way
    ```js
    example.dorm = "Florence Moore Hall";
    example["university"] = "Stanford";
    ```
- `for ... in` can iterate over properties of the object and properties inherited by the object, we can use `.hasOwnProperty()` to check if a property is on the object, not one inherited
    ```js
    for (let prop in example) { // note that prop is string, cannot use '.' to access that property
        if (example.hasOwnProperty(prop)) {
            console.log(prop + ": " + example[prop]);
        }
    }
    ```
- Objects can use numberic properties, just like arrays, and the index number will serve as property same as strings, and note that objects are dynamic and sparse
    ```js
    example[0] = "hello";
    example[1] = "goodbye";
    example[20] = "sparse";
    ```
- When we iterate through using `for ... in`, we get both the "named" properties and the "numbered" properties, and actually "numbered" properties will be converted to "name" properties literally and thus affect exisiting properties
- But note that objects do not have length
    ```js
    console.log(example.length); // undefined
    ```

## JavaScript Arrays
- Arrays are also objects, they can be defined literally or constructed by a standard object constructor
    ```js
    var array1 = ["hello", "goodbye", "test"];
    var array2 = new Array("hello", "goodbye", "test");
    ```
- Arrays are also sparse and dynamic, `for ... in` only iterates through items defined
    ```js
    array1[20] = "sparse";
    array1[35] = "efficient";
    for (let prop in array1) { // prop is each defined index
        if (anArray.hasOwnProperty(prop)) {
            console.log(prop + " : " + anArray[prop]);
        }
    }
    ```
- `for ... of` can also iterate over items by the values themselves, but it wiil list all elems including empty undefined ones
    ```js
    for (let item of array1) {
        console.log(item);
    }
    ```
- Arrays have a special `length` property
- Arrays also have special methods on them, like `push()`, `sort()`
- Since arrays are also objects, we can add regular properties to arrays, but they will not count toward length and will not be iterated by `for ... of`
    ```js
    array1.newProp = "New Non-Indexed Property";
    array1.another = "Awesome New Property";
    ```

## JavaScript Array-Like Objects
- Many methods return array-like objects, like `document.getElementsByTagName()` and these allow us to do some array-like operations, but not everything available on a real array
- Strings are also array-like objects
- `for ... of` can iterate over any iterable objects, including arrays and array-like objects
- Any array-like objects have `length` property, thus we can use a traditional `for` loop on array-like objects
- But only arrays can arise `forEach()`, which can call a function taking one or two parameters (item and index) on each item
    ```js
    realArray.forEach(item => console.log(item));
    realArray.forEach((item, index) => console.log(`${index}: ${item}`)); // note the order of the two paremeters
    ```

## JavaScript Methods
- Methods are functions attached to objects, can be defined in an object literal, just like general properties, `this` will refer to the object itself
    ```js
    var example = {
		name: "Molly",
		nickname: "FloPup",
		canine: true,
		age: 8,
		printInfo: function() {
			console.log(this.name);
		}
	};
    ```
- We can add a method after we defined the object just like general properties
    ```js
    example.detailedInfo = function() {
		console.log(this.name);
		console.log(this.age);
	};
    ```
- We can also define a function first and then attach that function as method on an object, which shows the duality of functions and methods
    ```js
    function printAge() {
        console.log(this.age);
    }
    example.getAge = printAge;
    example.getAge(); // 8
    ```
- If a function is called directly without an object, `this` in the function will refer to the global scope
    ```js
    var age = 2;
    printAge(); // 2
    ```
- `this.` should be specified to property names in object method bodies, otherwise a variable name might refer to a global variable, which will cause ambiguity
    ```js
    var x = "globalX";
    var obj = {
        x: "instanceX",
        badGetX: function () {
            console.log("badGetX retrieves " + x);
        },
        getX: function () {
            console.log("getX retrieves " + this.x);
        }
    };    
    obj.badGetX(); // "globalX"
    obj.getX(); // "instanceX"
    ```
- But within a global function, variables without `this.` will first look up the name in the local scope, while variables with `this.` will access variables in the global scope, which is different from object methods
    ```js
    var x = "globalX"
    function example() {
        var x = "localX";
        console.log(x); // "localX"
        console.log(this.x); // "globalX"
    }
    example();
    ``` 
- If we want to call a object method within another object method, we should also specify `this.` to the called function, otherwise the called function will refer to a funtion defined in the global scope
    ```js
    var x = "globalX";
    var obj = {
        x: "instanceX",
        getX: function () {
            console.log(this.x);
        },
        badCaller: function() {
            getX();
        },
        goodCaller: function() {
            this.getX();
        }
    };  
    obj.goodCaller(); // "instanceX"
    obj.badCaller(); // ERROR, getX() is not found in the global scope
    ```
- `this` depends on which object arises the method, or the function is a global function with no objects arising it, even if the function is defined as a global function, `this` can refer to an object if the function is assigned as an object method
    ```js
    var x = "globalX";
    var obj = {
        x: "instanceX",
        badCaller: function() {
            getX();
        },
        goodCaller: function() {
            this.getX();
        }
    };
    function getX() {
        console.log(this.x);
    }
    obj.getX = getX; // assign function to object method
    obj.goodCaller(); // "instanceX"
    obj.badCaller(); // "globalX"
    ```
- If we want to call a global function by an object, we can assign it as a method associated with the object, or instead use `apply()` on the function
    - a function including references to `this` can arise `apply()` taking an object, which will actually make the object arise the function as its method
        ```js
        function printInfo() {
            console.log("Name: " + this.name);
            console.log("Dorm: " + this.dorm);
        }
        printInfo.apply({name: "Bonnie", dorm: "FloMo", age: 21});
        // "Name: Boonie"
        // "Dorm: FloMo"
        ```
    - in this case, a function could be a general method for any object, if applicable
    - if the function takes parameters, parameters can be passed as an array as the second parameter of `apply()`
        ```js
        function makeOlder(years) {
            this.age = this.age + years;
            console.log("Now Age: " + this.age);
        }

        makeOlder.apply({name: "Bonnie", age: 21}, [3]); // "Now Age: 24"
        ```
- `call()` is very similar to `apply()`, except taking parameters of the called functions directly after the object instead of an array of parameters
    ```js
    makeOlder.call({name: "Bonnie", age: 21}, 3);
    ```
- `bind()` takes an existing function and an object and creates a new function that the new function calls the original function arised the object provided
    - it does not need parameters for the method since it does not call the returned method immediately
        ```js
        var makeBonnieOlder = makeOlder.bind({name: "Bonnie", age: 21});
        makeBonnieOlder(3);
        ```
    - it can actually also take part of parameters of the method to be called, which will be bound along with the object and the returned method
        ```js
        var makeBonnieThreeYearsOlder = makeOlder.bind({name: "Bonnie", age: 21}, 3);
        makeBonnieThreeYearsOlder();
        ```
    - it is handy for assigning handler function, especially when we want to add a list of similar event handlers on similar elems, since `.addEventListener()` need a function as the second parameter
        ```js
        var options = [
            {name: "Sports",
            price: 1800},
            {name: "Standard",
            price: 1500},
            {name: "Economy",
            price: 1200} 
        ];
        for (var opt of options) {
            var newHeader = document.createElement("h1");
            newHeader.innerHTML = opt.name;
            newHeader.addEventListener("click",
                (function() {
                    alert("price:" + this.price); // opt will not be explictly referenced within the function body
                }).bind(opt), // opt will be referenced by this in the function body
            false);
            document.documentElement.appendChild(newHeader);
        }
        ```

7/14 1:16:00
